------------------------------------------------------------------
Сортировка слиянием через корутины.
Язык: С.
Время: 2 недели.
------------------------------------------------------------------

На диске лежат файлы, в них числа в строковом виде в произвольном
порядке разделенные пробелом. Нужно отсортировать каждый файл и
затем слить их в один большой. То есть выполнить сортировку
слиянием.

Сортировка одного отдельно взятого файла должна выполняться в
С корутине, в собственном контексте. Алгоритм сортировки файла -
любой.

Считать, что все файлы в память помещаются, даже одновременно.

Корутины должны быть реализованы через swapcontext() или
setjmp()/longjump(). Сортировка должна быть реализована
самостоятельно, без использования встроенных библиотечных функций
сортировки вида qsort, system("sort ...") и прочих. Запрещено
реализовывать квадратичные сортировки вроде пузырька. Нужно
работать с файлами через числовой файловый дескриптор и функции
read/write, или через FILE * и функции подобные fscanf, fprintf и
тд. Нельзя использовать iostream, ostream, istream и прочие IO из
STL.

Далее немного информации о каждом способе реализации, один из
которых вам надо выбрать. Не пугайтесь непонятных функций вроде
mmap, setjump/longjump, mprotect, sigaltstack, которые встретятся
ниже и в примерах example_jmp.c, example_swap.c. Понимание их
работы придет постепенно в процессе прохождения курса. А пока надо
просто начать ими пользоваться.

* setjump/longjump - это "длинный" goto, который позволяет прыгать
в произвольное место стека программы. У каждого процесса есть
область памяти, называемая стек. Когда программа вызывает любую
функцию, она увеличивает стек, кладет на него аргументы и
локальные переменные этой функции. Когда функция кончается, то
стек уменьшается обратно. При использовании longjump придется
учитывать, что у всех корутин будет общий стек, и они будут
видеть локальные переменные друг друга. Значит нужно хранить все
используемые переменные внутри структуры, описывающей корутину. В
примере example_jmp.c можно видеть, что внутри функции
my_coroutine нет ни одной локальной переменной - все лежит в
структуре struct task. Кроме того, результат setjump становится
невалиден сразу после возврата из функции, сделавшей setjump, так
как стек сворачивается и метка, созданная в setjump, станет
испорченной, а потому вся часть кода, выполняющаяся в корутине,
должна быть реализована через макросы или одну гигантскую функцию.
Однако сементика, похожая на goto, может кому-то показаться более
"родной", и нет ничего плохого в выборе реализации через setjump.

* swapcontext - это функция, которая позволяет подменять стек и
указатель текущего места выполнения программы. То есть вместо
одного стека, разделяемого между корутинами, у каждой корутины
стек будет свой, в отличие от longjump реализации. Функция
swapcontext берет на себя все то, что делает setjump/longjump, так
что не нужно беспокоиться, что одна корутина поменяет переменные
стека другой. Каждая корутина описывается структурой ucontext_t,
где вам нужно положить указатель на функцию, которую будет
выполнять корутина, и указатель на память для стека. Выделить ее
можно тремя способами, каждый из которых можно найти в примере
example_swap.c, и которые описаны ниже:

1. использовать обычный malloc() + mprotect() с флагами
   PROT_READ | PROT_WRITE | PROT_EXEC. Если на результате маллока
   не позвать mprotect, то эта память будет непригодна для стека.
   Дело в том, что память стека должна быть исполняемой, то есть
   иметь флаг PROT_EXEC. А куча, откуда берет память malloc, не
   имеет этого флага по умолчанию.
   Пример:

   void *stack = malloc(stack_size);
   mprotect(stack, stack_size, PROT_READ | PROT_WRITE |
                               PROT_EXEC);
   ucontext_t context;
   context.uc_stack.ss_sp = stack;
   context.uc_stack.ss_size = stack_size;

2. использовать malloc() + sigaltstack(). Это наиболее каноничный
   способ, который используется в библиотеках корутин даже тогда,
   когда переключение контекстов делается без swapcontext(), на
   ассемблере.

   void *stack = malloc(stack_size);
   stack_t ss;
   ss.ss_sp = stack;
   ss.ss_size = stack_size;
   ss.ss_flags = 0;
   sigaltstack(&ss, NULL);
   ucontext_t context;
   context.uc_stack.ss_sp = stack;
   context.uc_stack.ss_size = stack_size;

3. использовать mmap() с флагами PROT_READ | PROT_WRITE |
   PROT_EXEC. Это почти тоже самое, что первый способ, но только
   чуть менее эффективный в общем случае.

   void *stack = mmap(NULL, stack_size, PROT_READ | PROT_WRITE |
                      PROT_EXEC, MAP_ANON | MAP_PRIVATE, -1, 0);
   ucontext_t context;
   context.uc_stack.ss_sp = stack;
   context.uc_stack.ss_size = stack_size;

Учтите, что размер стека обычно должен быть не меньше 32Kb, а на
Mac от 64Kb.

У корутин должен быть планировщик, который будет их переключать.
Есть несколько вариантов.

  - 15 баллов: после каждой выполненной строки делается
    переключение.
  - 20 баллов: каждой из N корутин выдается по T / N миллисекунд,
    где T - target latency, подаваемое на вход. После каждой
    строки проверять, что у процесса кончилось время. Если да, то
    переключать.
  - 25 баллов: тоже, что на 15, но чтение с диска должно быть
    асинхронным. Смотреть aio_read в man или google.com.

Вход: имена файлов, которые надо отсортировать, через аргументы
командной строки. Для варианта на 20 баллов добавляется target
latency первым аргументом. Все время вводится в микросекундах.

Выход: сколько программа работала суммарно и сколько каждая
корутина. Вывести время в микросекундах. Для задания на 20 баллов
нужно еще выводить сколько раз каждая задача отдала управление
другой, чтобы убедиться, что target latency соблюдается.

Для тестирования программы вы можете использовать свои файлы или
генерировать их с помощью скрипта generator.py. Пример, который
должен у вас работать на 15 баллов:

$> python3 generator.py -f test1.txt -c 10000 -m 10000
$> python3 generator.py -f test2.txt -c 10000 -m 10000
$> python3 generator.py -f test3.txt -c 10000 -m 10000
$> python3 generator.py -f test4.txt -c 10000 -m 10000
$> python3 generator.py -f test5.txt -c 10000 -m 10000
$> python3 generator.py -f test6.txt -c 100000 -m 10000

$> ./main test1.txt test2.txt test3.txt test4.txt test5.txt test6.txt

Для проверки результата можно использовать скрипт checker.py. Все
скрипты написаны с расчетом на python 3.

С чего начать? Рекомендуемый план выполнения задания такой:

- реализовать обычную сортировку, которая бы сортировала один файл;
  протестировать этот код;

- расширить решение, сделав обычную сортировку слиянием, без корутин; проверить
  уже на реальных тестах, что она работает. Это позволит далее сосредоточиться
  на только добавлении корутин, и не тратить время на отладку сортировки;

- добавить "корутинность", использовав примеры example_jmp.c и example_swap.c.

